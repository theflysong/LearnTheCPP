# virtual函数,static，抽象类与继承

## 继承

我们在写程序是常常会遇到这么一个问题：这里拿MC举例:

* 沙子和砂砾都受重力影响
* 有16种颜色的羊毛
* 所有的食物都可以吃
* ........

我们不可能为多个相似但又不同的事物编写多个不同的类。那样，代码将会极为冗长。我们不能坐视不管！这些事物都有共同的特点。我们可以把这些共同的特点写在一个类里，事情就迎刃而解了。

这就是继承的概念。让多个相似的类继承与一个类，从而提高代码的复用性。在C++里，继承一般都这么写:

```cpp
class [类名] : [继承方式] [被继承的类] , [继承方式] [被继承的类]....
```

与Java不同,C++支持多继承。

我们拿上面的第一个例子开刀:

```cpp
class 受重力影响方块:
{
    //TODO
}

class 沙子 : public 受重力影响方块
{
    //TODO
}

class 砂砾 : public 受重力影响方块
{
    //TODO
}
```

我们称被继承的类为基类，继承的类为派生类。

基类的私有成员不可以被派生类直接访问。

继承方式有三种:`public`,`protected`,`private`:

* `public`:基类的`public`成员成为派生类的`public`成员，基类的`protected`成员成为派生类的`protected`成员。
* `protected`:基类中所有非`private`的成员都成为派生类的`protected`成员。
* `private`:基类中所有非`private`的成员都成为派生类的`private`成员。

一般都使用`public`继承方式。

## static

在写程序时，我们可能希望某一个类的一个成员可以被所有实例共享~~(共享单车)~~。我们只要声明该成员为静态的即可。

声明一个成员为静态的方法如下:

```cpp
static  [成员名];
```

static的成员必须要在类外进行初始化。static的成员没有this指针（因为它被所有实例共享）。

你有可能希望一个类可以被这个类的所有实例共享。你有两种方法：

1. 如果你只是单纯的像避免名称冲突，使用namespace:

   ```cpp
   namespace MyIO
   {
       void printf();
       void scanf();
   }
   ```

2. 如果你希望使用OOP思想:

   ```cpp
   static class [类名]
   {
       [访问级别]:
       	static [成员];
   }
   ```

   static的类中的所有成员都必须是static的。

## virtual函数

首先声明一点——子类可以赋值给父类的实例，也就是: `[基类] a = [派生类] b `是合法的。但父类不可以赋值给子类的实例，也就是: `[派生类] a = [基类] b`是非法的。

我们再拿MC举例子：

* 僵尸和骷髅都会攻击玩家，但僵尸是近战，骷髅是远程。
* 打破泥土和钻石块都会掉落物品，但泥土掉落的是泥土，钻石块掉落的是钻石块~~(绕口令)~~
* 原石和基岩都可以放置在地上。但原石放置在地上是原石，基岩放置在地上是基岩。~~(绕口令*2)~~
* .......

我们希望有一种方法，使僵尸类和骷髅类的父类怪物类的攻击方法能够被僵尸类和骷髅类重新写过~~(绕口令*3)~~，这样就可以通过调用父类的方法使用不同的攻击方式，这就是OOP的多态思想，这种方法就被称为覆写。由于C++的动态绑定较弱，所以我们需要声明一个函数为虚函数。格式如下:

```cpp
virtual [成员函数];
```

由于virtual的成员是通过隐式调用this指针来实现的，而static成员没有this指针，所以virtual和static不能共存。

## 抽象类

你不能创建抽象类的实例，只能创建抽象类子类的实例。

要指定一个类为抽象类，只需声明其中一个函数为纯虚函数。纯虚函数是一个虚函数，必须要被子类覆写才能使用。

声明纯虚函数只要在声明虚函数后加上个`= 0`，也就是:

```cpp
virtual [成员函数] = 0;
```

你就声明了一个纯虚函数。包含这个纯虚函数的类就是一个抽象类。